<!DOCTYPE html>
<html lang="en">
	<head>
		<title>LEGO</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
            #camera_controller{
                position:absolute;
                z-index:10;
                width:100px;
                height:100px;
                background:rgba(128,128,128,0.5);
                border-radius:50%;
                bottom:20px;
                left:20px;
                display:none;
            }
            #camera_controller_ball{
                display:none;
                position:relative;
                width:30%;
                height:30%;
                border-radius:50%;
                left:50%;
                top:50%;
                margin-left:-15%;
                margin-top:-15%;
                box-shadow:1px 3px 2px rgba(128,128,128,0.8);
                background:rgba(255,255,255,0.5);
            }

		</style>
	</head>
	<body>
        <div id="camera_controller">
            <div id="camera_controller_ball"></div>
        </div>

		<script src="js/three.min.js"></script>

		<script src="js/Detector.js"></script>

		<script>
//var imgurl='http://7xiljm.com1.z0.glb.clouddn.com/images/tools/logo.png';
var imgurl='../images/test.jpg';

            window.requestAnimationFrame= (function () { 
                return window.requestAnimationFrame || 
                window.webkitRequestAnimationFrame || 
                window.mozRequestAnimationFrame || 
                window.oRequestAnimationFrame || 
                // if all else fails, use setTimeout 
                function (callback) { 
                    return window.setTimeout(callback, 1000 / 60); // shoot for 60 fps 
                }; 
            })(); 
            window.cancelAnimationFrame= (function () { 
                return window.cancelAnimationFrame || 
                window.webkitCancelAnimationFrame || 
                window.mozCancelAnimationFrame || 
                window.oCancelAnimationFrame || 
                function (id) { 
                    window.clearTimeout(id); 
                }; 
            })(); 
            function checkMobile(){
                if(/AppleWebKit.*Mobile/i.test(navigator.userAgent) 
                        || /Android/i.test(navigator.userAgent) 
                        || /BlackBerry/i.test(navigator.userAgent) 
                        || /IEMobile/i.test(navigator.userAgent) 
                        || (/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/.test(navigator.userAgent))){
                            if(/iPad/i.test(navigator.userAgent)){
                                if(/MicroMessenger/i.test(navigator.userAgent)){
                                    return 3; //微信
                                }
                                return 2;//平板
                            }else{
                                if(/MicroMessenger/i.test(navigator.userAgent)){
                                    return 3; //微信
                                }
                                return 1;//手机
                            }
                        }else{
                            return 0;
                        }
            }
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
            var cameraController;
            var cameraControllerBall;
			var camera, scene, renderer;
            var cameraLookAt=new THREE.Vector3();
			var plane, cube;
			var mouse, raycaster, isShiftDown = false;

			var rollOverMesh, rollOverMaterial;
			var blockGeo, cylinderGeo;
            // Atomic Block 8mm*3.2mm*8mm
            // Basic  Block 8mm*9.6mm*8mm
            // Cylinder     height 1.7mm , diameter 5mm

            var r=0.01;//camera radius
            var rx=30;//camera rx
            var ry=30;//camera ry
            var cameraOffsetX=0;
            var cameraOffsetY=0;
            var cameraOffsetZ=0;
            var cameraX=0;
            var cameraY=0;
            var cameraZ=0;
            var sphere1;
            var sphere2;
            var sphere3;
            var cylinder={
                h:17,
                d:50
            };
            var block={
                h:32,
                w:80
            };

            function rotateCamera(rx,ry){
                rx=-rx;ry=-ry;
                rx=rx>=90?90:rx;
                rx=rx<=-90?-90:rx;
                var A=ry*Math.PI/180;
                var B=rx*Math.PI/180;
                cameraZ=r*Math.sin(A)*Math.cos(B);
                cameraX=r*Math.cos(A)*Math.cos(B);
                cameraY=r*Math.sin(B);
            }
            function genRandomMaterial(){
                var material= new THREE.MeshBasicMaterial({color:Math.random()*255*255*255,opacity:0.8,transparent:true});
                var material = new THREE.MeshPhongMaterial( { color: 0xff00ff, specular: 0xffffff, shininess: 1, morphTargets: true, vertexColors: THREE.FaceColors, shading: THREE.FlatShading } );
                var material=new THREE.MeshLambertMaterial({color:Math.random()*0xffffff});
                return material;
                
            }

			var objects = [];

			init();

			function init() {
                rotateCamera(rx,ry);

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				container.appendChild( info );

				camera = new THREE.PerspectiveCamera( 140, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( cameraX, cameraY, cameraZ);
				camera.lookAt(cameraLookAt);

				scene = new THREE.Scene();

				blockGeo = new THREE.BoxGeometry( block.w, block.h, block.w);
				cylinderGeo = new THREE.CylinderGeometry( cylinder.d/2,cylinder.d/2,cylinder.h,30);

				// grid

				var size = block.w*40, step = block.w;

				var geometry = new THREE.Geometry();

				for ( var i = - size; i <= size; i += step ) {

					geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

					geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

				}

				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

				var line = new THREE.LineSegments( geometry, material );
				//scene.add( line );

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.PlaneBufferGeometry( block.w*80, block.w*80);
				geometry.rotateX( - Math.PI / 2 );

                var planeMaterial=new THREE.MeshBasicMaterial( { visible: false } );
                plane = new THREE.Mesh( geometry, planeMaterial );
				//scene.add( plane );

				objects.push( plane );

                //sphere
                var sphereGeo1=new THREE.SphereGeometry(500,40,40,0,Math.PI);
                var sphereGeo2=new THREE.SphereGeometry(500,40,40,0,Math.PI);
                var sphereGeo3=new THREE.SphereGeometry(500,40,40,0,Math.PI);
                THREE.ImageUtils.crossOrigin='*';
                var sphereImage1=THREE.ImageUtils.loadTexture('../images/dst2.jpg');
                var sphereImage2=THREE.ImageUtils.loadTexture('../images/dst1.jpg');
                var sphereImage3=THREE.ImageUtils.loadTexture('../images/out3.png');
                var sphereMaterial1=new THREE.MeshBasicMaterial({
                        map:sphereImage1,
                        transparent:true,
                        polygonOffset: true,
                        polygonOffsetFactor: -0.1,
                        side:THREE.DoubleSide
                });
                var sphereMaterial2=new THREE.MeshBasicMaterial({
                        map:sphereImage2,
                        transparent:true,
                        polygonOffset: true,
                        polygonOffsetFactor: -0.2,
                        side:THREE.DoubleSide
                });
                var sphereMaterial3=new THREE.MeshBasicMaterial({
                        map:sphereImage3,
                        transparent:true,
                        side:THREE.DoubleSide
                });
                sphere1=new THREE.Mesh(sphereGeo1,sphereMaterial1);
                sphere2=new THREE.Mesh(sphereGeo2,sphereMaterial2);
                sphere3=new THREE.Mesh(sphereGeo3,sphereMaterial3);

                //sphere1.rotateZ(-Math.PI/2);
                //sphere2.applyMatrix(new THREE.Matrix4().makeRotationZ(-Math.PI/2));
                sphere2.applyMatrix(new THREE.Matrix4().makeRotationY(Math.PI*1));
                //sphere3.applyMatrix(new THREE.Matrix4().makeRotationZ(-Math.PI/2));
                sphere3.applyMatrix(new THREE.Matrix4().makeRotationY(Math.PI*4/3));
                //scene.add(sphere1);
                //scene.add(sphere2);
                //scene.add(sphere3);

                var sphereGeo=new THREE.SphereGeometry(500,40,40);
                THREE.ImageUtils.crossOrigin='*';
                var sphereImage=THREE.ImageUtils.loadTexture(imgurl);
                var sphereMaterial=new THREE.MeshBasicMaterial({
                        map:sphereImage,
                        transparent:true,
                        polygonOffset: true,
                        side:THREE.DoubleSide
                });
                sphere=new THREE.Mesh(sphereGeo,sphereMaterial);
                scene.add(sphere);
                //sphere end

				//Lights

                // add subtle ambient lighting
                var ambientLight = new THREE.AmbientLight(0x0c0c0c);
                scene.add(ambientLight);

                // add spotlight for the shadows
                var spotLight = new THREE.SpotLight(0xffffff);
                spotLight.position.set(-500, 600, -500);
                spotLight.castShadow = true;
                scene.add(spotLight);

                //Lights end

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.gammaInput = true;
				renderer.gammaOutput = true;

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.cullFace = THREE.CullFaceBack;
				container.appendChild( renderer.domElement );

                cameraController=document.getElementById('camera_controller');
                cameraControllerBall=document.getElementById('camera_controller_ball');
                
                if(checkMobile()){
				    container.addEventListener( 'touchmove', onDocumentMouseMove, false );
				    container.addEventListener( 'touchstart', onDocumentMouseDown, false );
				    container.addEventListener( 'touchend', onDocumentMouseUp, false );
                    cameraController.addEventListener('touchmove',onControllerMouseMove,false);
                    cameraController.addEventListener('touchstart',onControllerMouseDown,false);
                    cameraController.addEventListener('touchend',onControllerMouseUp,false);

                }else{
				    container.addEventListener( 'mousemove', onDocumentMouseMove, false );
				    container.addEventListener( 'mousedown', onDocumentMouseDown, false );
				    container.addEventListener( 'mouseup', onDocumentMouseUp, false );
				    container.addEventListener( 'keydown', onDocumentKeyDown, false );
				    container.addEventListener( 'keyup', onDocumentKeyUp, false );
                }

				//

				window.addEventListener( 'resize', onWindowResize, false );
                animate();

			}


            var controllerMovingX=0;
            var controllerMovingY=0;
            var controllerMoving=false;
			function onControllerMouseMove( event ) {
				event.preventDefault();
                var x=parseInt(event.clientX>=0?event.clientX:event.touches[0].pageX);
                var y=parseInt(event.clientY>=0?event.clientY:event.touches[0].pageY);

                var w=100;
                x-=cameraController.offsetLeft+w/2;
                y-=cameraController.offsetTop+w/2;
                if(Math.pow(x*x+y*y,0.5)>50){
                    return;
                }
                controllerMovingX=x;
                controllerMovingY=y;
                controllerMoving=true;
                cameraControllerBall.style['-webkit-transform']='translateX('+x+'px) translateY('+y+'px)';
            }
            function onControllerMouseDown(event){
                var x=parseInt(event.clientX>=0?event.clientX:event.changedTouches[0].clientX);
                var y=parseInt(event.clientY>=0?event.clientY:event.changedTouches[0].clientY);
            }
			function onControllerMouseUp( event ) {
				event.preventDefault();
                var x=parseInt(event.clientX>=0?event.clientX:event.changedTouches[0].pageX);
                var y=parseInt(event.clientY>=0?event.clientY:event.changedTouches[0].pageY);
                controllerMovingY=0;
                controllerMovingX=0;
                controllerMoving=false;
                cameraControllerBall.style['-webkit-transform']='';
            }


            function onDocumentMouseDown(event){
                var x=parseInt(event.clientX>=0?event.clientX:event.changedTouches[0].clientX);
                var y=parseInt(event.clientY>=0?event.clientY:event.changedTouches[0].clientY);
                mouseDownX=x;
                mouseDownY=y;
                mouseClicking=true;
            }
            
            var mouseClicking=false;
            var mouseMoving=false;
            var mouseDownX;
            var mouseDownY;


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

                var x=parseInt(event.clientX>=0?event.clientX:event.touches[0].pageX);
                var y=parseInt(event.clientY>=0?event.clientY:event.touches[0].pageY);
                if(mouseClicking){
                    var offsetX=x-mouseDownX;
                    var offsetY=y-mouseDownY;

                    mouseDownX=x;
                    mouseDownY=y;
                    ry+=offsetX*0.3;
                    rx+=offsetY*0.3;
                    rotateCamera(rx,ry);

                    mouseMoving=true;
                    return;
                }

				mouse.set( ( x / window.innerWidth ) * 2 - 1, - ( y / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					//var intersect = intersects[ 0 ];

					//rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					//rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

				}


			}

			function onDocumentMouseUp( event ) {

                mouseClicking=false;
				event.preventDefault();
                var x=parseInt(event.clientX>=0?event.clientX:event.changedTouches[0].pageX);
                var y=parseInt(event.clientY>=0?event.clientY:event.changedTouches[0].pageY);

                if(mouseMoving){
                    mouseMoving=false;
                    return;
                }
                mouseMoving=false;

				mouse.set( ( x / window.innerWidth ) * 2 - 1, - ( y / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object != plane ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

					// create cube

					} else {
                        return;

                        var position= new THREE.Vector3().copy(intersect.point).add(intersect.face.normal);
                        //var block =genBlock(position);
                        var blocks =genBlocks(position,genRandomMaterial(),3,2,2);
                        for(var i in blocks){
                            scene.add(blocks[i]);
                            objects.push(blocks[i]);
                        }
						//scene.add( block);
						//objects.push( block);

					}

				}

			}

            function genBlock(position,material){
                if(!material){
                    material=genRandomMaterial();
                }
                var voxel = new THREE.Mesh( blockGeo, material);
                voxel.position.copy(position);
                voxel.position.x=Math.floor(voxel.position.x/block.w)*block.w;
                voxel.position.z=Math.floor(voxel.position.z/block.w)*block.w;
                voxel.position.y=Math.floor(voxel.position.y/block.h)*block.h;
                voxel.position.x+=block.w/2;
                voxel.position.y+=block.h/2;
                voxel.position.z+=block.w/2;
                var cy= new THREE.Mesh( cylinderGeo, material);
                cy.position.copy(voxel.position);
                cy.position.y+=block.h-cylinder.h/2;
                voxel.children.push(cy);

                voxel.castShadow = true;
                voxel.receiveShadow = true;
                
                return voxel;
            }

            function genBlocks(position,material,row,col,layer){
                var blocks=[];
                for(var i =0;i<row;++i){
                    for(var j=0;j<col;++j){
                        for(var k=0;k<layer;++k){
                            var p=new THREE.Vector3().copy(position);
                            p.x+=i*block.w;
                            p.z+=j*block.w;
                            p.y+=k*block.h;
                            blocks.push(genBlock(p,material));
                        }
                    }
                }
                return blocks;
            }

			function onDocumentKeyDown( event ) {

				switch( event.keyCode ) {

					case 16: isShiftDown = true; break;
					case 39: moveCamera(10,0,0); break;//right
					case 37: moveCamera(-10,0,0); break;//left
					case 38: moveCamera(0,0,-10); break;//up
					case 40: moveCamera(0,0,10); break;//down

				}

			}

            function moveCamera(x,y,z){
                var m = new THREE.Matrix4().makeTranslation(x,y,z);
                var cm= camera.matrix;
                cm.multiply(m);
                var p=cm.getPosition();
                cameraOffsetX=p.x-cameraX;
                //cameraOffsetY=p.y-cameraY;
                cameraOffsetZ=p.z-cameraZ;
            }

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;
				}

			}

			function render() {

                if(controllerMoving){
                    moveCamera(controllerMovingX,0,controllerMovingY);
                }
				camera.position.set( cameraX +cameraOffsetX, cameraY +cameraOffsetY, cameraZ +cameraOffsetZ);
                cameraLookAt.set(cameraOffsetX,cameraOffsetY,cameraOffsetZ);
				camera.lookAt(cameraLookAt);
				renderer.render( scene, camera );

			}
            function animate() {
                requestAnimationFrame( animate );
                render();
            }

		</script>

    <script type="text/javascript"> 
        var color = new Array('red', 'blue', 'yellow', 'green', '#00f', '#0ff'); 
        if(window.DeviceMotionEvent) { 
            var speed = 25; 
            var x = y = z = lastX = lastY = lastZ = 0; 
            window.addEventListener('devicemotion', function(){ 
                    var acceleration =event.accelerationIncludingGravity; 
                    x = acceleration.x; 
                    y = acceleration.y; 
                    //z = acceleration.z; 
                    if(Math.abs(x-lastX) > speed || Math.abs(y-lastY) > speed ) { 
                        document.body.style.backgroundColor = color[Math.round(Math.random()*10)%6]; 
                    } 
                    lastX = x; 
                    lastY = y; 
                    //lastZ = z; 
            }, false); 
        } 
    </script> 
	</body>
</html>
